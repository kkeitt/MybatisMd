# 1.4依赖

即便是最简单的应用程序也有一些可以协同工作的对象，以呈现用户最终看到的连贯的应用程序，本节将介绍如何定义多个独立的bean以及如果实现对象协作。

## 1.4.1依赖注入

使用DI原则会使代码更清晰，当对象提供其依赖项时，解耦更有效。对象即不查找其依赖性，也不知道依赖项所在的位置及类型。结果是，你的类变得容易测试，尤其是当依赖项是在单元测试中允许通过存根或模拟实现的接口或基础抽象类时。

DI主要有两种变体：

- 基于构造方法的依赖注入
- 基于setter的依赖注入

### 1.4.1.1基于构造方法的依赖注入

基于构造方法的依赖注入通过容器去调用带有一些参数的构造方法完成，每个参数代表一个依赖项。与之几乎等同的做法是调用一个有特定参数的静态工厂方法去实例化bean。

通过使用参数的类型进行构造方法的参数解析匹配，如果bean定义的构造方法参数中不存在潜在的歧义，那么在bean中定义构造方法参数的顺序就是实例化bean时将这些参数提供给构造方法的顺序。

考虑下面这个类

```java
package bean;
public class model{
    
    public model(X x,Y y){
        //...
    }
}
```

假设X和Y没有继承关系，也没有潜在的歧义存在，那么，下面的配置就可以正常工作。无需指定构造方法参数的位置或`<constructor-arg/>`元素的确切类型。

```xml
<beans>
	<bean id="model" class="bean.model">
    	<constructor-arg ref="x"/>
        <constructor-arg ref="y"/>
    </bean>
    
    <bean id="x" class="bean.X"/>
    <bean id="y" class="bean.Y"/>
</beans>
```

当引用另一个bean时，类型是已知的，并且可以进行匹配。当使用基本类型时，例如`<value>true</value/>`时，Spring无法确定值的类型，必须使用`type`属性显式指定参数的类型。

```java
package bean;
public class Person{
    private int age;
    private String name;
    public Person(int age,String name){
        this.age = age;
        this.name = name;
    }
}
```

```xml
<beans>
	<bean class="bean.Person" name="person">
    	<constructor-arg type="int" value="25"/>
        <constructor-arg type="java.lang.String" value="tom"/>
    </bean>
</beans>
```

可以使用`index`属性指定构造方法参数的位置,`index`从0开始

```xml
<beans>
	<bean class="bean.Person" name="person">
        <constructor-arg index="1" type="java.lang.String" value="tom"/>
    	<constructor-arg index="0" type="int" value="25"/>        
    </bean>
</beans>
```

可以使用`name`属性绑定对应的参数

```xml
<beans>
	<bean class="bean.Person" name="person">
        <constructor-arg name="name" type="java.lang.String" value="tom"/>
    	<constructor-arg name="age" type="int" value="25"/>        
    </bean>
</beans>
```

### 1.4.1.2基于setter的依赖注入

`