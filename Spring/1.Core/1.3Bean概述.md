# 1.3Bean概述

Spring的IOC容器管理着一个或多个bean，这些bean通过提供给容器的元数据配置信息创建而来。

在容器内部，这些bean由`BeanDefinition`对象表示，包含如下元数据：

- 包限定的类名：通常是bean的实际实现类
- Bean行为配置元素：bean在容器中的行为方式（scope, lifecycle callbacks等等）
- Bean在工作时所需要的其他Bean：也被称作合作者或依赖
- 在创建对象时需要的其他配置：例如连接池的连接数量限制

这些元数据会转换为构成每个bean定义的属性集合，下面的表格列出了这些属性

| 属性                     | 参见章节 | 章节名                   |
| ------------------------ | -------- | ------------------------ |
| Class                    | 1.3.2    | Instantiating Beans      |
| Name                     | 1.3.1    | 命名Beans                |
| Scope                    | 1.5      | Bean Scopes              |
| Constructor arguments    | 1.4.1    | Dependency Injection     |
| Properties               | 1.4.1    | Dependency Injection     |
| Autowiring mode          | 1.4.5    | Autowiring Collaborators |
| Lazy initialization mode | 1.4.4    | Lazy-initialized Beans   |
| Initialization method    | 1.6.1    | Initialization Callbacks |
| Destruction method       | 1.6.1    | Destruction Callbacks    |

除了包含有关如何创建特定bean的Bean信息对象外，`ApplicationContext`接口的实现类还允许把用户在容器外创建的对象注册到容器中。

这是通过`ApplicationContext`的`getBeanFactory`方法实现的，这个方法会返回`BeanFactory`接口的实现类`DefaultListableBeanFactory` ，这个类支持通过`registerSingleton`或`registerBeanDefinition`方法对象注册到容器中。

> 为了能让容器在自动装配及其他自省步骤时正确处理，Bean的元数据及手动创建的单例实例应该尽可能早的注册到容器中。虽然容器在某种程度上支持覆盖现有元数据及单例实例，但是在运行时（与访问工厂同时）向容器中注册新的bean并未得到官方支持，而且可能会导致并发访问异常或bean容器的不一致状态，或两者兼有。

## 1.3.1命名Beans

每个bean都有一个或多个标识符。这些标识符在托管bean的容器中必须是唯一的。一个bean通常只有一个标识符，但是，如果它需要多个，这些额外的可以被视为别名。

在基于XML文件的配置中，可以使用`id`属性，`name`属性，或两个都使用作为bean的标识符。

`id`属性让你准确的指定一个唯一的`id`，可以是字母，数字，特殊符号。如果你想为bean定义一个别名，可以使用`name`属性指定。`name`属性支持以`逗号`，`分号`或`空格`作为分隔符同时定义多个name值。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


    <bean class="java.util.Date" name="date;date1;date2"/>

</beans>
```

```java
@Test
public void mulitiname(){

    ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");

    Assert.assertNotNull(context.getBean("date"));

    Assert.assertNotNull(context.getBean("date1"));

    Assert.assertNotNull(context.getBean("date2"));
}
```

1. 如果同时指定了`id`属性和`name`属性，则`id`为标识符，`name`属性作为别名，两者都可以找到bean。

2. 如果没有提供`id`属性而提供了`name`属性，则`name`属性作为bean的标识符，需要在容器中保持唯一。

3. 如果`id`和`name`属性都没有提供，容器会默认将类的全限定名作为标识符

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
   
   
       <bean class="java.util.Date" name="date;date1;date2" id="realdate"/>
   
       <bean class="java.lang.String"/>
   
   </beans>
   ```

   ```java
   @Test
   public void defaultName(){
   
       ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
   
       Assert.assertNotNull(context.getBean(String.class.getCanonicalName()));
   
       Assert.assertEquals(
           context.getBean(String.class), 			                                                       context.getBean(String.class.getCanonicalName())
       );
   }
   ```

但是，如果你想通过使用`ref`元素或服务器定位器风格查找来通过name引用这个bean的话，必须提供`name`属性，不提供name的原因与使用内部beans和自动装配有关。

> Bean命名约定
>
> 在命名bean时，默认使用Java标准约定命名实例的属性名，即驼峰式命名，首字母小写。
>
> 例如：accountManager，userDao等等
>
> 统一的命名方式可以使你的配置易于阅读和理解。同时，如果你使用AOP的话，当你将通知应用于一组以name关联的bean时，会带来极大的方便。

> Spring在类路径下扫描组件时，会为未命名的组件生成标识符。通常情况下，将类名的首字母转为小写后，作为该类的标识符，例如：Person=>person，PersonAddress=>personAddress
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>        xmlns:content="http://www.springframework.org/schema/context"
>        xsi:schemaLocation="http://www.springframework.org/schema/beans
>        http://www.springframework.org/schema/beans/spring-beans.xsd
>        http://www.springframework.org/schema/context
>        http://www.springframework.org/schema/context/spring-context.xsd
>         ">
> 
>     <content:component-scan base-package="bean"/>
> 
> </beans>
> ```
>
> ```java
> @Test
> public void unnamedComponent()
> {
>     Assert.assertNotNull(context.getBean("person"));
> 	//错误，找不到标识符为Person的bean
>     Assert.assertNotNull(context.getBean("Person"));
> 	//错误，找不到标识符为bean.Person的bean
>     Assert.assertNotNull(context.getBean(Person.class.getCanonicalName()));
> }
> ```
>
> 当类名有多个字符，且第一和第二个字符都是大写时,直接将类名作为标识符，例如：IService=>IService

### 1.3.1.1在Bean的定义之外定义Bean的别名

我们可以为bean定义多个别名，但是在大型系统中，我们有时需要为其他配置文件中定义的bean定义别名。

在XML配置中，可以使用`alias`元素来实现

被引入的配置文件：sub.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean class="java.util.Random" name="subrandom"/>
</beans>
```

配置文件：config.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:content="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        ">
    <import resource="sub.xml"/>

    <bean class="java.util.Date" name="date;date1;date2" id="realdate"/>

    <bean class="java.lang.String"/>

    <content:component-scan base-package="bean"/>

    <alias name="subrandom" alias="mainrandom"/>

</beans>
```

通过`import`元素引入其他配置文件，通过`alias`元素，name为`subrandom`的bean可以通过`mainrandom`来引用。

```java
@Test
public void testAlias(){

    Assert.assertNotNull(context.getBean("subrandom"));

    Assert.assertNotNull(context.getBean("mainrandom"));

    Assert.assertEquals(context.getBean("subrandom"),context.getBean("mainrandom"));
}
```

如果使用Java配置，可以使用`@Bean`注解来实现为bean定义别名。

## 1.3.2实例化beans

bean的定义本质上是为了创建一个或多个对象。

### 1.3.2.1使用构造方法实例化

使用构造方法创建bean的时候，所有的普通类都可以使用并与Spring兼容。因此，开发中定义的类既不需要实现任意特定接口，也不需要以某种特定方式编码。简单的指定bean的类型就可以了。但是，根据为特定的bean使用的IOC容器类型的不同，bean可能需要提供一个默认（空）的构造方法。

### 1.3.2.2使用静态工厂方法实例化

当定义一个使用静态工厂方法创建的bean时，通过`class`属性指定一个包含静态工厂方法的类，并且通过`factory-method`属性指定工厂方法的名字。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:content="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        ">
    <bean class="bean.MainService" factory-method="instance"/>
</beans>
```

```java
package bean;

public class MainService {

    private MainService(){}

    public static MainService instance(){
        return new MainService();
    }
}
```

### 1.3.2.3通过实例工厂方法实例化

与通过静态工厂方法类似，可以通过调用容器中存在的bean的非静态方法来实例化新的bean。

要使用这个机制，首先要把`class`属性置空，在`factory-bean`属性中指定当前容器中某个bean的标识符，这个bean包含创建对象的实例方法，将`factory-method`属性设为工厂方法的名字。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


    <bean name="uuid" factory-bean="stringFactory" factory-method="uuid"/>

    <bean class="com.kkeitt.bean.StringFactory" id="stringFactory"/>

</beans>
```

```java
/**
** com.kkeitt.bean.StringFactory
**/
public class StringFactory {

    public String uuid(){
        return UUID.randomUUID().toString();
    }
}

```

```java
@Test
public void instanceFactoryMethod(){

    String str = (String) context.getBean("uuid");

    Assert.assertNotNull(str);

    Assert.assertTrue(str.length() == 36);
}
```

工厂bean可以提供多个实例工厂方法。

例如：在StringFactory中提供一个去掉UUID中的横线的字符串的方法

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


    <bean name="uuid" factory-bean="stringFactory" factory-method="uuid"/>

    <bean class="com.kkeitt.bean.StringFactory" id="stringFactory"/>

    <bean name="uuid2" factory-bean="stringFactory" factory-method="uuid2"/>
</beans>
```

```java
public class StringFactory {

    public String uuid(){
        return UUID.randomUUID().toString();
    }

    public String uuid2(){
        return uuid().replaceAll("-","");
    }
}
```

```java
@Test
public void instanceFactoryMethod(){

    String str = (String) context.getBean("uuid");

    Assert.assertNotNull(str);

    Assert.assertTrue(str.length() == 36);

    String str2 = (String) context.getBean("uuid2");

    Assert.assertNotNull(str2);

    Assert.assertTrue(str2.length() == 32);
}
```