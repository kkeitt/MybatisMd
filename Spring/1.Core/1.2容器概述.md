# 1.2容器概述

`org.springframework.context.ApplicationContext`接口代表Spring的IOC容器，复制实例化，配置，以及组装beans。

容器通过读取元数据配置获取要实例化，配置，和组装的对象，元数据配置可以是XML，注解或Java代码。

Spring提供了`ApplicationContext`接口的一些实现类，例如：

- `FileSystemXmlApplicationContext`：从XML文件中读取信息，需要向构造方法传入XML文件的完整路径
- `ClassPathXmlApplicationContext`:从XML文件中读取信息，需要向构造方法传入XML文件的路径，与`FileSystemXmlApplicationContext`不同的是，无需提供完整的路径，只需要正确配置CLASSPATH环境变量即可，容器会从CLASSPATH的路径里搜索配置文件
- `WebXmlApplicationContext`：Web应用中读取配置信息

使用XML定义元数据配置时，也可以让容器从注解或Java代码中读取配置，只需要在XML中加入少量配置即可开启这些额外的配置支持。

在大多数应用场景中，不需要显式的用代码实例化由容器管理的bean。

下面这张图展示了Spring是如何工作的。应用程序中的类与配置信息结合，在`ApplicationContext`创建及初始化完成之后，一个全配置及可执行的系统或应用就诞生了。

![](/images/20190526124254.png)

## 1.2.1元数据配置

元数据配置通常使用一个简单而又直观的XML文件配置，Spring框架从2.5版本开始支持基于注解的配置元数据，从3.0版本开始，基于Java代码的元数据配置在Spring核心中占有重要位置。

通常情况下，我们会配置以下几类对象

- service层对象
- 数据访问对象（DAO)
- 视图层对象（例如Struts的`Action`对象实例，SpringMvc的`Controller`）
- 基础设施类对象（例如Hibernate的`SessionFactories`，JMS的`Queues`等等

某些细粒度的对象不在容器中配置，因为这些对象通常由DAO或业务逻辑负责创建。

但是，可以通过在Spring中集成AspectJ，手动将这些对象交由IOC容器管理。具体参见5.10.1章。

下面的这个XML就是一个基础的配置结构

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">   
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

`id`属性是标识单个bean定义的字符串

`class`属性用全限定类名定义了bean的类型

## 1.2.2实例化一个容器

`ApplicationContext`的构造方法接受一个或多个资源字符串，容器会根据这些字符串，从各种外部资源中读取配置信息。

这些资源字符串可以是本地文件系统，Java类路径（CLASSPATH）等等。

```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml","dao.xml");
```

在多个XML文件中定义bean是非常有用的。通常，每一个XML配置文件代表技术体系结构中的一个逻辑层或模块。

可以使用应用上下文的构造方法加载所有的XML中定义的bean。这个构造方法接受多个`Resource`位置。

此外，可以使用`import`元素从其他文件中加载bean的定义。

```xml
<beans>
	<import resource="services.xml"/>
    <import resource="messages.xml"/>
    <import resource="/resoucre/dao.xml"/>
    <import resource="resource/net.xml"/>
</beans>
```

在父目录中使用使用相对路径`../`的这种做法可以使用，但是不推荐。因为这样会对当前应用之外的文件产生依赖。

特别是，不推荐在`classpath:`中使用，例如`classpaht:../services.xml`。当运行时环境解析的时候，会将类路径的父目录作为根类路径。当类路径配置发生改变时，可能导致选择错误的目录。

建议使用全限定的资源位置而不是相对路径，例如：`file:D:/config/services.xml`或`classpath:/config/services.xml`。但是这样应用程序又会和绝对路径耦合。

通常更可取的做法是间接的定位绝对路径，例如：通过`${..}`占位符可以在运行时解析JVM的系统属性。

命名空间本身提供了导入指令的功能。Spring提供的一系列XML命名空间中，还有其他可选的命名空间用于普通bean定义之外的配置功能。例如`context`和`util`。

## 1.2.3使用容器

通过`ApplicationContext`接口的`T getBean(String name,Class<T> requireType)`方法，可以检索指定的bean。

例如，获取一个Date类型的bean

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="date" class="java.util.Date"/>
</beans>
```

```java
ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring/main.xml");

Date date = context.getBean("date",Date.class);

DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

System.out.println(dateFormat.format(date));
```

除此之外，`ApplicationContext`接口还提供了其他检索bean的方法，但是，理想状态下，应用中的代码不应该直接调用这些方法来获取bean，而是通过元数据（例如：`Autowired`注解）声明对特定bean的依赖。