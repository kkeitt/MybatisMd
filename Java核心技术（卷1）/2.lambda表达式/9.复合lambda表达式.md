Java8提供的函数式接口都有为方便而设计的方法，提供了运行进行复合操作的方法。这意味着可以把多个简单的lambda表达式复合成更复杂的表达式，例如让一个函数的结果成为另一个函数的输入。

这些方法都是默认方法，因此并不违背函数式接口的定义。

#### 1.比较器复合

我们可以根据字符串数组每一个元素的长度进行排序，如果我们想逆序呢？Comparator接口有一个默认方法reversed可以帮我们做到。

```java
String []arr = {"2134","32432","41","3","42"};
Arrays.sort(arr,comparing(String::length).reversed());
System.out.println(Arrays.toString(arr));
```

> output:
>
> [32432, 2134, 41, 42, 3]

有时候我们想像SQL那样，根据多个条件，多步排序，按某个条件排序后会有两个或两个以上排序条件相等的数据，这时候需要进一步排序，Comparator提供了thenComparing方法，接受一个Comparator参数。

定义水果类，有两个属性，重量（weight）和产地（origin）

```java
class Fruit{
        private Integer weight;
        private String origin;

        public Integer getWeight() {
            return weight;
        }

        public void setOrigin(String origin) {
            this.origin = origin;
        }

        public String getOrigin() {
            return origin;
        }

        public void setWeight(Integer weight) {
            this.weight = weight;
        }

        public Fruit(Integer weight, String origin) {
            this.weight = weight;
            this.origin = origin;
        }

        @Override
        public String toString() {
            return "Fruit{" +
                    "weight=" + weight +
                    ", origin='" + origin + '\'' +
                    '}';
        }
}
```

先根据重量排序

```java
Fruit [] fruits = new Fruit[4];
fruits[0] = new Fruit(14,"america");
fruits[1] = new Fruit(23,"japan");
fruits[2] = new Fruit(5,"africa");
fruits[3] = new Fruit(23,"china");
Arrays.sort(fruits,compring(Fruit::getWeight));
Arrays.asList(fruits).forEach(System.out::println);
```

> output:
>
> Fruit{weight=5, origin='africa'}
> Fruit{weight=14, origin='america'}
> Fruit{weight=23, origin='japan'}
> Fruit{weight=23, origin='china'}

有两个水果重量都是23，这时可以用产地属性的字典排序再排一次

```java
Arrays.sort(fruits,comparing(Fruit::getWight).thenComparing(Fruit::getOrigin));
```

> output:
>
> Fruit{weight=5, origin='africa'}
> Fruit{weight=14, origin='america'}
> Fruit{weight=23, origin='china'}
> Fruit{weight=23, origin='japan'}

#### 2.谓词复合

谓词接口包括3个方法，negate，and，or，可以重用已有的Predicate来创造更复杂的谓词。negate可以返回Predicate的非。

我们先定义产自Japan的水果Predicate

```java
Predicate<Fruit> fromJapan = fruit -> fruit.getOrigin().equals("japan");
```

那么不是产自Japan的水果就可以这么定义

```java
Predicate<Fruit> notFromtJapan = fromJapan.negate();
```

如果想定义既不是产自Japan，同时重量小于20的水果，可以用and来定义

```java
Predicate<Fruit> notAndHeavy = notFromJapan.and(f->fruit.getWeight()<20);
```

同样，要表达或，可以用or方法

```java
Predicate<Fruit> or = notFromJapan.or(fruit->fruit.getWeight()>15);
```

and和or是按照在表达式链中的位置，由左向右确定优先级的，因此a.or(b).and(c)可以看作（a||b) && c。

#### 3.函数复合

可以把Function接口所代表的lambda表达式复合起来，Function接口提供了andThen和compose方法，他们都会返回Function的一个实例。

andThen会返回一个函数，假设有一个函数f给数字加1，f(x) = x+1,另一个函数g给数字乘2，g(x)=x*2,可以将这两个函数组装成一个函数，先给数字加1，再给结果乘2。即g(f(x))

```java
Function<Integer,Integer> fun = i->i+1;	
fun = fun.andThen(i->i*2);
System.out.println(fun.apply(1));
```

> output:
>
> 8

compose方法与andThen相反，等同于f(g(x))

```java
Function<Integer,Integer> fun = i->i+1;	
fun = fun.compose(i->i*2);
System.out.println(fun.apply(1));
```

> output:
>
> 3

对于一些类似流水线作业式的操作，例如构造器模式，可以使用这些方法进行处理。