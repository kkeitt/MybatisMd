#### 1.函数式接口

只有一个抽象方法的接口称为函数式接口。

函数式接口**有**且只有**一个**抽象方法，默认方法因为有方法体，所以不算抽象方法。如果一个接口声明的方法重写了Object类的public方法，这些方法不算做抽象方法，比如Comparator接口里重写了Object类的equals方法，这个方法不算在抽象方法之内，虽然没有方法体。

可以通过**lambda表达式**，**方法引用**，**构造器引用**来创建函数式接口的实例。

#### 2.lambda表达式

lamdba表达式是Java8提供的一种用于实现传递代码的轻量级的语法。

lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例，具体来说，是函数式接口一个具体实现的实例。使用匿名内部类也可以完成同样的操作，只不过代码略微冗余，需要提供一个实现，然后直接内联将它实例化。

lambda表达式可以被赋给一个变量，或传递给一个接受函数式接口作为参数的方法。

以Runnable接口为例，在没有lambda之前，使用匿名内部类的代码

```java
Runnable r1 = new Runnable(){
    @Override
    public void run(){
        System.out.println('Hello');
    }
};
```

使用lambda表达式的代码

```java
Runnable r2 = ()->System.out.println("Hello");
```

这就是上面所说的，将整个表达式作为函数式接口Runnable的实例。

再看前面的根据字符串长度排序的比较器的例子。原代码如下

```java
class LengthComparator implements Comparator<String>{
    @Override
    public int compare(String first,String second){
        return first.length()-second.length();
    }
}
String arr[] = {"1","342","42","43242"};
//排序
Arrays.sort(arr,new LengthComparator());
```

上面这个例子中的排序代码，用lambda表达式可以改写为

```java
Arrays.sort(arr,(String first,String second)->first.length()-second.length());
```

这就是lambda表达式的基本形式

> **(参数)->{表达式}**

1. 如果表达式只有一行，可以省略花括号。
2. 如果参数只有一个，而且参数类型可以推导得出，可以省略括号。
3. 即使没有参数，也要提供空括号。

如果可以推导出lambda表达式的参数类型，可以在代码中省略参数类型

```java
Arrays.sort(arr,(first,second)->first.length()-second.length());
```

在上面的代码里，编译器可以推导出first和second必然是String，因为这个lambda表达式将赋给一个LengthComparator对象，lambda表达式的返回类型总是由上下文推导得出。

另外和方法一样，对于有返回值的lambda表达式，不能在一些分支上有返回值，而在另一些分支上没有返回值。

```java
//不合法的写法
(x)->{if (x>0) return 1;}
```

#### 3.函数描述符

函数式接口的抽象方法的签名基本上就是lambda表达式的签名，这种抽象方法叫做**函数描述符**。

例如函数式接口Runnable接口的抽象方法run的函数描述符可以表示为

> ()->void

因为run方法没有任何参数，也没有返回值。

#### 4.异常

如果需要lambda接口抛出异常，有两种方法

1.定义自己的函数式接口，并声明受检查异常

2.把lambda包含在try/catch块中

Java内置的函数式接口都没有声明异常，这种情况下可以显示捕捉受检查异常。

#### 5.闭包

lambda表达式可以捕获外围作用域中变量的值，在lambda中，只能引用不会改变的变量。如果在lambda中改变变量，并发执行多个操作就会不安全。

另外如果在lambda表达式中引用变量，而这个变量可能在外表被改变，这也是不合法的。lambda中捕获的变量必须实际上是最终变量，即初始化之后就不会再为它赋值。

lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规 则。在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。 

```java
Path first = Paths.get("7usr/Mn"); 
Couparator<String> comp = (first, second) -> first.length() - second.length();
//Error: Variable first already defined 
```

在lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。