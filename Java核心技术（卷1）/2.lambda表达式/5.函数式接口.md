Java8在java.util.function这个包中引入了几个新的函数式接口。

1.Predicate

Predicate接口提供了一个名叫test的抽象方法，它接受泛型对象T,返回一个布尔值。

在需要一个涉及类型T的布尔表达式时，就可以使用这个接口。

例如：从一个List中筛选出符合指定条件的数据，并返回这些数据

```java
public static <T> List<T> filter(List<T> origin,Predicate<T> pre){
    List<T> res = new ArrayList<>();
    for(T t:origin){
        if(pre.test(t)){
            res.add(t);
        }
    }
    return res;
}
List<String> test = new ArrayList<>();
test.add("1fwefE345FE");
test.add("2FRE,;[]453");
test.add("3FE324WFewf");
test.add("4FEW45FE4WF");
test.add("5wew35w5r34");
//筛选出所有只含有0-9A-Z的字符串
List<String> res = filter(test,str->str.match("[0-9A-Z]+"));
System.out.println(res);
```

> output:
>
> [4FEW45FE4WF]

2.Consumer

Consumer接口提供了一个accept方法，该方法接受一个泛型对象T,没有返回值。

如果需要访问对象，并执行某些操作，就可以使用这个接口。

例如：传入一个List，遍历并打印其中的元素

```java
public static <T> void forEachPrint(List<T> list,Consumer<T> consumer){
    for(T t:list){
        consumer.accept(t);
    }
}
List<String> list = new ArrayList<>();
list.add("tom");
list.add("jack");
list.add("rose");
list.add("shiina");
list.add("ringo");
forEachPrint(list,s -> System.out.println(s));
```

> output:
>
> tom
> jack
> rose
> shiina
> ringo

3.Function

Function接口提供了一个apply方法，它接受一个泛型对象T，并返回一个泛型对象R。

如果你需要定义一个lambda表达式，将输入对象的信息映射到输出，就可以使用这个接口。

例如：将一个String类型的List映射为每个String长度的Integer类型List

```java
public static <T,R> List<R> map(List<T> list,Function<T,R> function){
    List<R> lengths = new ArrayList<>();
    for(T t:list){
        lengths.add(function.apply(t));
    }
    return lengths;
}   
String [] arr = {"1","22","333","4444","55555"};
List<String> list = Arrays.asList(arr);
System.out.println(map(list,s->s.length()));
```

> output:
>
> [1, 2, 3, 4, 5]

4.原始类型特化

Java在1.5版本中引入了自动拆装箱特性，但是装箱的本质就是把原始类型包裹起来，保存在堆中，装箱后的值需要更多的内存。

Java8中提供了专门的函数式接口，以便在输入和输出都是原始类型时避免自动装箱操作。

一般来说，针对专门的输入参数类型的函数式接口的名称都要加上对应的原始类型前缀，比如DoublePredicate、IntConsumer、LongBinaryOperator、IntFunction等。

Function接口还有针对输出参数类型的变种：ToIntFunction<T>、IntToDoubleFunction等。

以IntPredicate为例

```java
public static even(int num,IntPredicate pre){
    return pre.test(num);
}
int num = 4;
int num2 = 3;
System.out.println(even(num,i->i%2==0));
System.out.println(even(num2,i->i%2==0));
```

> output:
>
> true
>
> false

