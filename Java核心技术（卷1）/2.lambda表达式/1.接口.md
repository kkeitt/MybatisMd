#### 在Java中，接口不是类，而是对类的一组需求描述，这些实现接口的类要遵从接口描述的统一格式进行定义

可以类比计算机的USB协议，对于计算机来说，它并不关心通过USB接口接入的设备具体是什么，它只关心这个设备有没有实现USB协议。

我们假设USB协议定义了一个read方法，用于从设备中读取信息，那么只要设备支持USB协议，就必然可以通过调用这个方法读取数据，设备本身的其他特性对计算机来说并不重要，在计算机看来，只要这个设备支持USB协议，就必然提供了read方法。

所以接口可以看作一种协定，对于调用方来说，只要知晓接口的定义就可以调用相应的方法，而无需知晓其他细节。因为实现了接口的类必然提供了相应的服务。

在jdk1.8中，允许在接口中增加静态方法（必须有方法体）

```java
interface Usb{
    static String getName(){
        return 'Usb';
    }
}
System.out.println(Usb.getName());
```

> output:
>
> Usb

通过default关键字可以提供一个默认方法

```java
interface Usb{
    default int read(){
        return -1;
    }
}
```

如果在一个接口中定义了一个默认方法，又在父类或其他接口中定义了同样的方法，会造成冲突，Java的解决规则如下：

> 1.父类优先。如果父类提供了一个具体方法，那么同名且参数类型相同的默认方法会被忽略

```java
interface Top{
    default String getName(){
        return "TOP";
    }
}
class Father{
    public String getName(){
        return "father"
    }
}

class Child extends Father implements Top{
    
}
Child c1 = new Child();
System.out.println(c1.getName());
Father c2 = new Child();
System.out.println(c2.getName());
Top c3 = new Child();
System.out.println(c3.getName());
```

> output:
>
> father
>
> father
>
> father

> 2.接口冲突。
>
> 1.)如果一个接口A提供了一个默认方法，另一个接口B提供了一个同名且参数类型相同的方法，那么不论B接口的方法是不是默认方法，编译器都会提示错误，要解决这个问题，必须在实现类中重写这个方法。
>
> 2.)如果两个接口都没有提供默认实现，那么实现类要么实现这个方法，要么作为抽象类不实现这个方法。

```java
interface Sub{
    default String getName(){
        return "Sub";
    }
}
interface Hub{
    String getName();
}
class Child implements Sub,Hub{
    //无论Hub的getName是不是默认方法，Child类必须重写getName方法
    @Overrile
    public String getName(){
        return Sub.super.getName();
    }
}
```

