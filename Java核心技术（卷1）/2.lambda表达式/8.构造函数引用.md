对于一个现有的构造函数，可以用类名和关键字new来创建一个引用，这与指向静态方法的方法引用类似。

对于一个无参的构造函数，可以这样做

```java
Supplier<String> supplier = String::new;
String str = supplier.get();
```

这就等价于

```java
Supplier<String> supplier = ()->new String();
String str = supplier.get();
```

String类有一个以字符串为参数的构造函数，要这样构造，可以用Function接口

```java
Function<String,String> fun = String::new;
String s1 = fun.apply("123");
System.out.println(s1);
```

> output:
>
> 123

这就等价于

```java
Function<String,String> fun = (str)->new String(str);
String s1 = fun.apply("123");
```

参数有两个时可以使用BiFunction接口

```java
class Person{
    private Integer age;
    private String name;
    public Person(Integer age,String name){
            this.age = age;
            this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
            "age=" + age +
            ", name='" + name + '\'' +
            '}';
    }
}
BiFunction<Integer,String,Person> personSupplier = Person::new;
Person person = personSupplier.apply(1,"jack");
System.out.println(person);
```

> output:
>
> Person{age=1, name='jack'}

等价于：BiFunction<Integer,String,Person> personSupplier =(age,name)->new Person(age,name);

BiFunction的函数描述符

```java
R apply(T t, U u);
```

利用构造函数引用可以做到一些语义化的效果，例如创建不同年龄的各种人

```java
class Chinese extends Person{
    
}
class Japanese extends Person{
    
}
class Person{
    private Integer age;
    public Person(Integer age){
        this.age = age;
    }
    public Person(){
            
    }
}
static Map<String,Function<Integer,Person>> map = new HashMap<>();
static{
 	  map.put("chinese",Chinese::new);
      map.put("japanese",Japanese::new);
}
static Person getPerson(Integer age,String personName){
    return map.get(personName.toLowerCase())
        .apply(age);
}
```

使用map得到了Function<Integer,Person>,然后根据构造函数引用，得到指定年龄的人。

对于参数大于2个的情况，可以自定义函数式接口来解决，例如对于3个参数的构造函数引用

```java
public interface TriFunction<T,U,V,R>{
    R apply(T t,U u,V v);
}
```

