#### 1.catch语句中抛出异常

在catch语句中可以抛出一个异常，这样做的目的是改变异常的类型。

#### 2.try/catch/finally

建议耦合try/catch和try/finally

```java
try{
    try{
        //do something
    }finally{
        //resources close
    }
}catch(Exception e){
    //catch
}
```

内层的try/finally确保关闭资源，外层的try/catch捕获异常，包括finally中出现的错误。

#### 3.finally中的return语句

当finally中包含return时，会出现一种意想不到的情况。

假设在try中使用return退出，在方法返回前，会执行finally中的语句，如果finally中也有一个return语句，那么finally中的返回值会覆盖原始的返回值。

```java
try{
    return 0;
}finally{
    return -1;
}
```

最终的返回值是-1。

同样的，如果在try中抛出了异常，这个异常本应该交由调用者处理，但是如果finally中也抛出了一个异常，这时候调用者处理的是finally中抛出的异常，try中抛出的异常信息会丢失。

#### 4.try-with-resource语法糖

在Java中，对于流，文件，socket连接等资源，都是需要手动关闭的。

在Java7之前，通常是在finally中进行关闭操作，以保障在任何情况下都可以安全关闭。但是，在打开多个资源的情况下，关闭操作变得极为复杂，为了确保安全，不得不在finally中嵌套finally，打开的资源越多，嵌套越深，甚至会出现关闭资源的代码比业务代码还要多的情况。

在Java7中，Java提供了try-with-resource语法糖，在编译时为我们插入相关关闭代码，无需我们手动编写。

为了配合这一语法糖，资源必须实现AutoClosable接口或其子接口。重写close方法。

```java
public class Connection implements AutoCloseable {
    @Override
    public void close() throws Exception {
        System.out.println("资源已关闭");
    }
    public void open()throws Exception{
        System.out.println("打开资源");
    }
}
```

这样，在使用这个资源时，无需手动调用close方法，只需要在try后面紧跟的括号中声明变量即可，支持声明多个变量。

```java
try(Connection c = new Connection()){
     c.open();
}catch (Exception e){
	e.printStackTrace();
}
```

> output:
>
> 打开资源
>
> 资源已关闭

我们在try和catch没有显式调用close方法，但是close方法自动执行了。

反编译这段代码，可以看到编译器帮我们生成了资源关闭操作的相关代码。

```java
try
    {
      Connection c = new Connection();Throwable localThrowable3 = null;
      try
      {
        c.open();
      }
      catch (Throwable localThrowable1)
      {
        localThrowable3 = localThrowable1;throw localThrowable1;
      }
      finally
      {
        if (c != null) {
          if (localThrowable3 != null) {
            try
            {
              c.close();
            }
            catch (Throwable localThrowable2)
            {
              localThrowable3.addSuppressed(localThrowable2);
            }
          } else {
            c.close();
          }
        }
      }
    }
    catch (Exception localException) {}
```

在这段编译器生成的代码里，有一个方法需要注意

```java
localThrowable3.addSuppressed(localThrowable2);
```

通过addSuppressed方法可以把一个异常附加到另一个异常上面，避免出现前面抛出的异常信息被后面抛出的异常信息覆盖。

从上面这段编译器生成的代码中可以看到，在执行try中的语句c.open()时，编译器会在前面事先声明一个Throwable类型的变量localThrowable3。

当try中的语句抛出异常时，用localThrowable3变量引用这个异常，然后再把这个异常抛出。

然后开始执行finally中的代码，在手动关闭资源之前，先判断localThrowable3是不是null。如果是，直接执行close方法。如果不是，则说明try中抛出了异常，接着执行close方法，如果close方法抛出异常，就会把这个异常信息附加到localThrowable3中去。因为close方法抛出的异常被catch了，所以调用者最终得到的是localThrowable1，也即localThrowable3。

为了展示这个效果，我们在Connection类的open方法和close方法中手动抛出异常

```java
@Override
public void close() throws Exception {
    System.out.println("资源已关闭");
    throw new Exception("关闭资源失败！！");
}

public void open()throws Exception{
    System.out.println("打开资源");
    throw new Exception("打开资源失败！！");
}
```

> output:
>
> java.lang.Exception: 打开资源失败！！
> 资源已关闭
> 	at chapter04.Connection.open(Connection.java:13)
> 	at chapter04.AutoCloseTest.main(AutoCloseTest.java:8)
> 	Suppressed: java.lang.Exception: 关闭资源失败！！
> 		at chapter04.Connection.close(Connection.java:8)
> 		at chapter04.AutoCloseTest.main(AutoCloseTest.java:9)

可以看到，close方法抛出的异常信息被附加到了try中的open方法抛出的异常信息里一起打印出来。而不是只打印了close方法抛出的异常，避免了异常信息丢失。

另外,还有一个需要特别注意的地方，在使用try-with-resource时，一定要了解资源的close方法的实现逻辑，否则可能造成资源泄露。

例如：在BIO中大量使用了装饰器模式，调用装饰器的close方法时，本质上是调用的被包裹的流的close方法

```java
try (FileInputStream fin = new FileInputStream(new File("input.txt"));
     GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(new File("out.txt")))) {
    byte[] buffer = new byte[4096];
    int read;
    while ((read = fin.read(buffer)) != -1) {
        out.write(buffer, 0, read);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

我们从FileInputStream中读取数据，将数据写入到GZIPOutputStream中。

GZIPOutputStream的close方法代码如下

```java
public void close() throws IOException {
        if (!closed) {
            finish();
            if (usesDefaultDeflater)
                def.end();
            out.close();
            closed = true;
        }
}
```

out变量代表的是被装饰的FileOutPutStream,可以看到，在调用out的close方法之前，还调用了finish方法，这个方法会继续向out中写入压缩数据，如果这时候出现异常，接下来的close方法就不会被执行，然而这个close方法才是底层资源的关闭方法。

因此，为了保证底层资源的close方法一定被调用，我们需要单独声明底层资源，上面的代码需要改成

```java
try (FileInputStream fin = new FileInputStream(new File("input.txt"));
     FileOutputStream fout = new FileOutputStream(new File("out.txt"));
     GZIPOutputStream out = new GZIPOutputStream(fout)) {
    byte[] buffer = new byte[4096];
    int read;
    while ((read = fin.read(buffer)) != -1) {
        out.write(buffer, 0, read);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

我们单独声明了FileOutputStream变量，由于编译器会自动生成关闭代码，这样肯定可以保证真正的流被关闭。

